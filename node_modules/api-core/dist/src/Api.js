"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Api = void 0;
const ApiRequestParser_1 = require("./request/ApiRequestParser");
const ApiQueryBuilder_1 = require("./query/ApiQueryBuilder");
const ApiEdgeRelation_1 = require("./relations/ApiEdgeRelation");
const ApiAction_1 = require("./query/ApiAction");
const ExternalApiEdge_1 = require("./edge/ExternalApiEdge");
const LocalApiResolver_1 = require("./resolver/LocalApiResolver");
const pkg = require('../../package.json');
class Api {
    constructor(service, ...edges) {
        this.edges = [];
        this.relations = [];
        this.actions = [];
        this.findEdge = (name, plural = true) => {
            return this.resolver.resolveEdge(name, plural);
        };
        this.parseRequest = (requestParts, type = null) => __awaiter(this, void 0, void 0, function* () {
            const result = yield this.parser.parse(requestParts);
            if (type)
                result.type = type;
            return result;
        });
        this.buildQuery = (request) => {
            const query = this.queryBuilder.build(request);
            query.request = request;
            return query;
        };
        this.use = (action) => {
            this.actions.unshift(action);
            return this;
        };
        this.action = (name, execute, triggerKind = ApiAction_1.ApiActionTriggerKind.OnInput) => {
            this.actions.unshift(new ApiAction_1.ApiAction(name, execute, triggerKind));
            return this;
        };
        this.metadata = () => {
            return {
                info: this.info || { title: 'API' },
                version: pkg.version,
                services: [this.service],
                edges: this.edges
                    .filter(edge => !edge.external)
                    .map(edge => edge.metadata()),
                relations: this.relations
                    .map(relation => relation.toJSON())
            };
        };
        this.extension = {};
        this.get = (key) => this.extension[key];
        this.set = (key, value) => this.extension[key] = value;
        this.service = service;
        this.edges = edges;
        this.parser = new ApiRequestParser_1.ApiRequestParser(this);
        this.queryBuilder = new ApiQueryBuilder_1.ApiQueryBuilder(this);
        this.resolver = new LocalApiResolver_1.LocalApiResolver(this);
    }
    findRelation(name) {
        return this.resolver.resolveRelation(name);
    }
    findRelationOfEdge(edge, name) {
        const edgeName = edge.name || edge;
        return this.resolver.resolveRelationOfEdge(edgeName, name);
    }
    findRelationTo(edge, name) {
        const edgeName = edge.name || edge;
        return this.resolver.resolveRelationTo(edgeName, name);
    }
    findRelationFrom(edge, name) {
        const edgeName = edge.name || edge;
        return this.resolver.resolveRelationFrom(edgeName, name);
    }
    edge(edge) {
        this.edges.push(edge);
        edge.api = this;
        return this;
    }
    ;
    relation(relation) {
        relation.from.relations.push(relation);
        relation.to.relations.push(relation);
        this.relations.push(relation);
        return this;
    }
    static fromMetadata(metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const api = new Api(metadata.services[0] || {});
            api.info = metadata.info;
            for (let edge of metadata.edges) {
                api.edge(new ExternalApiEdge_1.ExternalApiEdge(edge, api));
            }
            for (let relation of metadata.relations) {
                api.relation(yield ApiEdgeRelation_1.ApiEdgeRelation.fromJSON(relation, api));
            }
            return api;
        });
    }
    prepare() {
        return __awaiter(this, void 0, void 0, function* () {
            for (let edge of this.edges) {
                yield edge.prepare(this);
            }
        });
    }
}
exports.Api = Api;
Api.defaultIdPostfix = "Id";
Api.defaultIdField = "id";
//# sourceMappingURL=Api.js.map