"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiRequestParser = exports.ApiRequestPathParser = void 0;
const ApiRequest_1 = require("./ApiRequest");
const OneToOneRelation_1 = require("../relations/OneToOneRelation");
const OneToManyRelation_1 = require("../relations/OneToManyRelation");
const ApiEdgeError_1 = require("../query/ApiEdgeError");
const ApiEdgeMethod_1 = require("../edge/ApiEdgeMethod");
class ApiRequestPathParser {
    constructor(api) {
        this.api = api;
    }
    findEdgeByName(name) {
        return this.api.findEdge(name);
    }
    findRelationByName(edge, name) {
        return this.api.findRelationOfEdge(edge, name);
    }
    findMethodByName(edge, name, forEntry) {
        if (forEntry) {
            return edge.methods.find((method) => method.name === name &&
                (method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Entry || method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Edge));
        }
        else {
            return edge.methods.find((method) => method.name === name &&
                (method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Collection || method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Edge));
        }
    }
    parse(segments) {
        return __awaiter(this, void 0, void 0, function* () {
            let requestPath = new ApiRequest_1.ApiRequestPath();
            let lastEdge = null, lastRelation = null, wasEntry = false;
            while (segments.length) {
                let segment = segments.shift() || '';
                if (lastEdge) {
                    let relation = yield this.findRelationByName(lastEdge, segment);
                    if (relation) {
                        if (relation instanceof OneToOneRelation_1.OneToOneRelation) {
                            requestPath.add(new ApiRequest_1.RelatedFieldPathSegment(lastEdge, relation));
                            lastEdge = relation.to;
                            lastRelation = relation;
                            wasEntry = true;
                        }
                        else if (wasEntry && relation instanceof OneToManyRelation_1.OneToManyRelation) {
                            lastEdge = relation.to;
                            lastRelation = relation;
                            wasEntry = false;
                        }
                        else {
                            throw new ApiEdgeError_1.ApiEdgeError(400, "Unsupported Relation: " + segment);
                        }
                    }
                    else {
                        let method = this.findMethodByName(lastEdge, segment, wasEntry);
                        if (method) {
                            requestPath.add(new ApiRequest_1.MethodPathSegment(lastEdge, method));
                            wasEntry = true;
                        }
                        else if (!wasEntry) {
                            requestPath.add(new ApiRequest_1.EntryPathSegment(lastEdge, "" + segment, lastRelation));
                            wasEntry = true;
                        }
                        else {
                            throw new ApiEdgeError_1.ApiEdgeError(400, `Missing Relation/Method: ${lastEdge.name} -> ${segment}`);
                        }
                    }
                }
                else {
                    let edge = yield this.findEdgeByName(segment);
                    if (edge) {
                        lastEdge = edge;
                        wasEntry = false;
                    }
                    else {
                        throw new ApiEdgeError_1.ApiEdgeError(400, "Missing Edge: " + segment);
                    }
                }
            }
            if (lastEdge && !wasEntry) {
                requestPath.add(new ApiRequest_1.EdgePathSegment(lastEdge, lastRelation));
                lastEdge = null;
            }
            return requestPath;
        });
    }
}
exports.ApiRequestPathParser = ApiRequestPathParser;
class ApiRequestParser {
    constructor(api) {
        this.api = api;
        this.pathParser = new ApiRequestPathParser(api);
    }
    parse(segments) {
        return __awaiter(this, void 0, void 0, function* () {
            let request = new ApiRequest_1.ApiRequest(this.api);
            request.path = yield this.pathParser.parse(segments);
            return request;
        });
    }
}
exports.ApiRequestParser = ApiRequestParser;
//# sourceMappingURL=ApiRequestParser.js.map