{"version":3,"file":"ApiRequestParser.js","sourceRoot":"","sources":["../../../src/request/ApiRequestParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {ApiEdgeDefinition} from \"../edge/ApiEdgeDefinition\";\nimport {ApiEdgeRelation} from \"../relations/ApiEdgeRelation\";\nimport {\n    ApiRequestPath, RelatedFieldPathSegment, EntryPathSegment, EdgePathSegment, ApiRequest,\n    MethodPathSegment\n} from \"./ApiRequest\";\nimport {OneToOneRelation} from \"../relations/OneToOneRelation\";\nimport {OneToManyRelation} from \"../relations/OneToManyRelation\";\nimport {ApiEdgeError} from \"../query/ApiEdgeError\";\nimport {Api} from \"../Api\";\nimport {ApiEdgeMethod, ApiEdgeMethodScope} from \"../edge/ApiEdgeMethod\";\n\nexport class ApiRequestPathParser {\n    api: Api;\n\n    constructor(api: Api) {\n        this.api = api;\n    }\n\n    private findEdgeByName(name: string) {\n        return this.api.findEdge(name);\n    }\n\n    private findRelationByName(edge: ApiEdgeDefinition, name: string) {\n        return this.api.findRelationOfEdge(edge, name)\n    }\n\n    private findMethodByName(edge: ApiEdgeDefinition,\n                             name: string|null|undefined,\n                             forEntry: boolean): ApiEdgeMethod|undefined {\n        if(forEntry) {\n            return edge.methods.find((method: ApiEdgeMethod) =>\n                method.name === name &&\n                (method.scope == ApiEdgeMethodScope.Entry || method.scope == ApiEdgeMethodScope.Edge));\n        }\n        else {\n            return edge.methods.find((method: ApiEdgeMethod) =>\n                method.name === name &&\n                (method.scope == ApiEdgeMethodScope.Collection || method.scope == ApiEdgeMethodScope.Edge));\n        }\n    }\n\n    async parse(segments: string[]): Promise<ApiRequestPath> {\n        let requestPath = new ApiRequestPath();\n\n        let lastEdge: ApiEdgeDefinition|null = null,\n            lastRelation: ApiEdgeRelation|null = null,\n            wasEntry = false;\n        while(segments.length) {\n            let segment = segments.shift() || '';\n\n            if(lastEdge) {\n                let relation: ApiEdgeRelation|undefined = await this.findRelationByName(lastEdge, segment);\n                if(relation) {\n                    if(relation instanceof OneToOneRelation) {\n                        requestPath.add(new RelatedFieldPathSegment(lastEdge, relation));\n                        lastEdge = (relation as OneToOneRelation).to;\n                        lastRelation = relation;\n                        wasEntry = true;\n                    }\n                    else if(wasEntry && relation instanceof OneToManyRelation) {\n                        lastEdge = (relation as OneToManyRelation).to;\n                        lastRelation = relation;\n                        wasEntry = false;\n                    }\n                    else {\n                        throw new ApiEdgeError(400, \"Unsupported Relation: \" + segment);\n                    }\n                }\n                else {\n                    let method: ApiEdgeMethod|undefined = this.findMethodByName(lastEdge, segment, wasEntry);\n\n                    if(method) {\n                        //TODO: Add support for method parameters\n                        requestPath.add(new MethodPathSegment(lastEdge, method));\n                        wasEntry = true;\n                    }\n                    else if (!wasEntry) {\n                        requestPath.add(new EntryPathSegment(lastEdge, \"\" + segment, lastRelation));\n                        wasEntry = true;\n                    }\n                    else {\n                        throw new ApiEdgeError(400, `Missing Relation/Method: ${lastEdge.name} -> ${segment}`);\n                    }\n                }\n            }\n            else {\n                let edge = await this.findEdgeByName(segment);\n\n                if(edge) {\n                    lastEdge = edge;\n                    wasEntry = false;\n                }\n                else {\n                    throw new ApiEdgeError(400,\"Missing Edge: \" + segment);\n                }\n            }\n        }\n\n        if(lastEdge && !wasEntry) {\n            requestPath.add(new EdgePathSegment(lastEdge, lastRelation));\n            lastEdge = null;\n        }\n\n        return requestPath\n    }\n\n}\n\nexport class ApiRequestParser {\n    api: Api;\n    private pathParser: ApiRequestPathParser;\n\n    constructor(api: Api) {\n        this.api = api;\n        this.pathParser = new ApiRequestPathParser(api);\n    }\n\n    async parse(segments: string[]): Promise<ApiRequest> {\n        let request = new ApiRequest(this.api);\n        request.path = await this.pathParser.parse(segments);\n        return request;\n    }\n}\n"]}