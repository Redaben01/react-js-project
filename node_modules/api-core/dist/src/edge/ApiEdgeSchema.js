"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiEdgeSchema = exports.ApiEdgeSchemaTransformation = exports.SubSchema = exports.JSONDate = exports.SchemaReference = exports.Mixed = void 0;
const parse = require('obj-parse'), deepKeys = require('deep-keys'), SimpleSchema = require('simpl-schema').default;
class Mixed {
}
exports.Mixed = Mixed;
exports.SchemaReference = SimpleSchema.oneOf(String, Mixed);
exports.JSONDate = SimpleSchema.oneOf(String, Number, Date);
class SubSchema extends SimpleSchema {
    constructor(schema, options, ...args) {
        if (!options)
            options = { requiredByDefault: false };
        super(schema, options, ...args);
        this._apiCoreOriginal = schema;
    }
    get original() {
        return this._apiCoreOriginal;
    }
}
exports.SubSchema = SubSchema;
class ApiEdgeSchemaTransformation {
    constructor(input, output, modelFields, schemaType, schemaField = "") {
        this.applyToInput = input;
        this.applyToOutput = output;
        this.affectedSchemaField = schemaField;
        this.affectedModelFields = modelFields;
        this.parsedField = parse(schemaField);
        this.schemaType = schemaType;
    }
    setSchemaField(field) {
        this.affectedSchemaField = field;
        this.parsedField = parse(field);
    }
}
exports.ApiEdgeSchemaTransformation = ApiEdgeSchemaTransformation;
class ApiEdgeSchema {
    constructor(schema, typedSchema = null, fields) {
        this.fields = [];
        this.schema = null;
        this.originalSchema = null;
        this.fieldMatrix = {};
        this.renameMatrix = {};
        this.transformField = (field) => {
            return this.renameMatrix[field] || field;
        };
        this.transformFields = (fields) => {
            let output = [];
            for (const field of fields) {
                const transformedFields = this.fieldMatrix[field];
                if (transformedFields) {
                    transformedFields.forEach((f) => output.push(f));
                }
                else {
                    if (this.renameMatrix[field])
                        output.push(this.renameMatrix[field]);
                    else
                        output.push(field);
                }
            }
            return output;
        };
        this.cleanAndValidateModel = (model, modifier = false) => {
            if (this.schema) {
                const context = this.schema.newContext();
                context.clean(model, {
                    mutate: true,
                    filter: true,
                    autoConvert: true,
                    removeEmptyStrings: false,
                    trimStrings: false,
                    getAutoValues: !modifier
                });
                model = modifier
                    ? { $set: model }
                    : model;
                context.validate(model, { modifier });
                return {
                    valid: context.isValid(),
                    errors: context.validationErrors().map(({ name }) => context.keyErrorMessage(name))
                };
            }
            return { valid: true };
        };
        this.fields = fields || deepKeys(schema, true);
        this.originalSchema = typedSchema;
        this.schema = typedSchema
            ? new SimpleSchema(typedSchema, { requiredByDefault: false })
            : null;
        this.transformations = [];
        for (let i = 0; i < this.fields.length; ++i) {
            const transform = this.createTransformation(this.fields[i], schema, typedSchema);
            if (transform)
                this.transformations.push(transform);
        }
    }
    createInputTransformer(schemaField, transform) {
        if (transform === "=") {
            return (schema, model) => schemaField.assign(model, schemaField(schema));
        }
        else if (transform[0] === "=") {
            const fieldName = transform.substring(1), modelField = parse(fieldName);
            return (schema, model) => modelField.assign(model, schemaField(schema));
        }
        else
            throw "Not Supported Transform";
    }
    static createOutputTransformer(schemaField, transform) {
        if (transform === "=") {
            return (model, schema) => schemaField.assign(schema, schemaField(model));
        }
        else if (transform[0] === "=") {
            const fieldName = transform.substring(1), modelField = parse(fieldName);
            return (model, schema) => schemaField.assign(schema, modelField(model));
        }
        else {
            throw "Not Supported Transform";
        }
    }
    createTransformation(schemaField, schema, typedSchema) {
        const parsedSchemaField = parse(schemaField), transform = parsedSchemaField(schema);
        if (transform instanceof ApiEdgeSchemaTransformation) {
            transform.setSchemaField(schemaField);
            let transformedFields = this.fieldMatrix[transform.affectedSchemaField];
            if (transformedFields) {
                transform.affectedModelFields.forEach((field) => transformedFields.push(field));
            }
            else {
                this.fieldMatrix[transform.affectedSchemaField]
                    = transform.affectedModelFields.map((field) => field);
            }
            this.fixFields(schemaField);
            return transform;
        }
        else if (typeof transform === "string") {
            this.renameMatrix[schemaField] = transform.substring(1);
            return new ApiEdgeSchemaTransformation(this.createInputTransformer(parsedSchemaField, transform), ApiEdgeSchema.createOutputTransformer(parsedSchemaField, transform), [schemaField], typedSchema ? typedSchema[schemaField] : Mixed, schemaField);
        }
    }
    fixFields(fieldName) {
        this.fields = this.fields.filter((field) => field.indexOf(fieldName + ".") == -1);
    }
}
exports.ApiEdgeSchema = ApiEdgeSchema;
//# sourceMappingURL=ApiEdgeSchema.js.map