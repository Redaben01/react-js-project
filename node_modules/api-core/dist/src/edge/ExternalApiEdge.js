"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExternalApiEdge = exports.ExternalApiProvider = void 0;
const ApiEdgeQueryResponse_1 = require("./ApiEdgeQueryResponse");
const ApiEdgeSchema_1 = require("./ApiEdgeSchema");
const ApiEdgeDefinition_1 = require("./ApiEdgeDefinition");
const SchemaTypeMapper_1 = require("./utils/SchemaTypeMapper");
const ApiEdgeMethod_1 = require("./ApiEdgeMethod");
class ExternalApiProvider {
    constructor(metadata, api) {
        this.metadata = metadata;
        this.api = api;
    }
    edge() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.prepare();
            return new ExternalApiEdge(this.metadata, this.api, this);
        });
    }
}
exports.ExternalApiProvider = ExternalApiProvider;
class ExternalApiEdge extends ApiEdgeDefinition_1.ApiEdge {
    constructor(metadata, api, provider) {
        super();
        this.getEntry = (context) => {
            return this.provider.getEntry(context);
        };
        this.listEntries = (context) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.listEntries(context);
        });
        this.createEntry = (context, body) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.createEntry(context, body);
        });
        this.updateEntry = (context, body) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.updateEntry(context, body);
        });
        this.patchEntry = (context, body) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.patchEntry(context, body);
        });
        this.removeEntry = (context, body) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.removeEntry(context, body);
        });
        this.exists = (context) => __awaiter(this, void 0, void 0, function* () {
            return this.provider.exists(context);
        });
        this.api = api;
        this.name = metadata.name;
        this.pluralName = metadata.pluralName;
        this.idField = metadata.idField;
        const publicSchema = {};
        metadata.fields.forEach((field) => publicSchema[field] = '=');
        this.schema = new ApiEdgeSchema_1.ApiEdgeSchema(publicSchema, metadata.typings
            ? SchemaTypeMapper_1.SchemaTypeMapper.importSchema(metadata.typings)
            : null);
        const callMethod = provider ? provider.callMethod : () => __awaiter(this, void 0, void 0, function* () { return new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(null); });
        for (let { name, scope, type, parameters } of metadata.methods) {
            this.methods.push(new ApiEdgeMethod_1.ApiEdgeMethod(name, callMethod, scope, type, parameters, false));
        }
        this.allowGet = metadata.allowGet;
        this.allowList = metadata.allowList;
        this.allowCreate = metadata.allowCreate;
        this.allowUpdate = metadata.allowUpdate;
        this.allowPatch = metadata.allowPatch;
        this.allowRemove = metadata.allowRemove;
        this.allowExists = false;
        this.external = true;
        this.url = metadata.url;
        if (provider)
            this.provider = provider;
    }
}
exports.ExternalApiEdge = ExternalApiEdge;
//# sourceMappingURL=ExternalApiEdge.js.map