"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiEdge = void 0;
const ApiEdgeQueryContext_1 = require("./ApiEdgeQueryContext");
const ApiEdgeMethod_1 = require("./ApiEdgeMethod");
const ApiRequest_1 = require("../request/ApiRequest");
const ApiEdgeAction_1 = require("./ApiEdgeAction");
const ApiEdgeQueryType_1 = require("./ApiEdgeQueryType");
const SchemaTypeMapper_1 = require("./utils/SchemaTypeMapper");
const ApiEdgeQuery_1 = require("./ApiEdgeQuery");
class ApiEdge {
    constructor() {
        this.methods = [];
        this.relations = [];
        this.actions = [];
        this.allowGet = true;
        this.allowList = true;
        this.allowCreate = true;
        this.allowUpdate = true;
        this.allowPatch = true;
        this.allowRemove = true;
        this.allowExists = true;
        this.external = false;
        this.resolve = () => Promise.resolve(true);
        this.metadata = () => {
            return {
                name: this.name,
                pluralName: this.pluralName,
                idField: this.idField,
                fields: this.schema.fields,
                methods: this.methods.map(m => ({
                    name: m.name,
                    type: m.acceptedTypes,
                    scope: m.scope,
                    parameters: m.parameters
                })),
                typings: this.schema.originalSchema
                    ? SchemaTypeMapper_1.SchemaTypeMapper.exportSchema(this.schema.originalSchema)
                    : undefined,
                allowGet: this.allowGet,
                allowList: this.allowList,
                allowCreate: this.allowCreate,
                allowUpdate: this.allowUpdate,
                allowPatch: this.allowPatch,
                allowRemove: this.allowRemove,
                allowExists: this.allowExists,
                external: this.external
            };
        };
        this.use = (action) => {
            this.actions.unshift(action);
            return this;
        };
        this.action = (name, execute, targetTypes = ApiEdgeQueryType_1.ApiEdgeQueryType.Any, triggerKind = ApiEdgeAction_1.ApiEdgeActionTriggerKind.BeforeEvent, triggers = ApiEdgeAction_1.ApiEdgeActionTrigger.Any, triggerNames = []) => {
            this.actions.unshift(new ApiEdgeAction_1.ApiEdgeAction(name, execute, targetTypes, triggerKind, triggers, triggerNames));
            return this;
        };
        this.relation = (name) => this.api.findRelationOfEdge(this.name, name);
        this.extension = {};
        this.get = (key) => this.extension[key];
        this.set = (key, value) => this.extension[key] = value;
    }
    edgeMethod(name, execute, acceptedTypes = ApiRequest_1.ApiRequestType.Any, parametersOrData = [], requiresData = true) {
        if (this.methods.find((method) => method.name === name))
            throw "A method with the same name already exists.";
        this.methods.push(new ApiEdgeMethod_1.ApiEdgeMethod(name, execute, ApiEdgeMethod_1.ApiEdgeMethodScope.Edge, acceptedTypes, parametersOrData, requiresData));
        return this;
    }
    ;
    collectionMethod(name, execute, acceptedTypes = ApiRequest_1.ApiRequestType.Any, parametersOrData = [], requiresData = true) {
        if (this.methods.find((method) => method.name === name &&
            (method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Collection || method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Edge)))
            throw "A collection method with the same name already exists.";
        this.methods.push(new ApiEdgeMethod_1.ApiEdgeMethod(name, execute, ApiEdgeMethod_1.ApiEdgeMethodScope.Collection, acceptedTypes, parametersOrData, requiresData));
        return this;
    }
    ;
    entryMethod(name, execute, acceptedTypes = ApiRequest_1.ApiRequestType.Any, parametersOrData = [], requiresData = true) {
        if (this.methods.find((method) => method.name === name &&
            (method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Entry || method.scope == ApiEdgeMethod_1.ApiEdgeMethodScope.Edge)))
            throw "An entry method with the same name already exists.";
        this.methods.push(new ApiEdgeMethod_1.ApiEdgeMethod(name, execute, ApiEdgeMethod_1.ApiEdgeMethodScope.Entry, acceptedTypes, parametersOrData, requiresData));
        return this;
    }
    ;
    method(options) {
        if (this.methods.find((method) => method.name === options.name)) {
            throw "A method with the same name already exists.";
        }
        this.methods.push(new ApiEdgeMethod_1.ApiEdgeMethod(options));
        return this;
    }
    buildQuery(type = ApiEdgeQueryType_1.ApiEdgeQueryType.Get, body = null) {
        return new ApiEdgeQuery_1.ApiEdgeQuery(this, type, new ApiEdgeQueryContext_1.ApiEdgeQueryContext(), body);
    }
}
exports.ApiEdge = ApiEdge;
//# sourceMappingURL=ApiEdgeDefinition.js.map