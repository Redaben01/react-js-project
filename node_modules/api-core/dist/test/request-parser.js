"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tap = require('tap');
const request = require("../src/request/ApiRequest");
const ApiEdgeMethod_1 = require("../src/edge/ApiEdgeMethod");
const ApiRequestParser_1 = require("../src/request/ApiRequestParser");
const OneToManyRelation_1 = require("../src/relations/OneToManyRelation");
const OneToOneRelation_1 = require("../src/relations/OneToOneRelation");
const Api_1 = require("../src/Api");
const entryMethod = () => { return new Promise((resolve, reject) => reject("entry")); };
const relatedEntryMethod = () => { return new Promise((resolve, reject) => reject("entry")); };
const collectionMethod = () => { return new Promise((resolve, reject) => reject("collection")); };
const edgeMethod = () => { return new Promise((resolve, reject) => reject("edge")); };
const edge1 = function () {
    this.name = "entry";
    this.pluralName = "entries";
    this.relations = [];
    this.methods = [
        new ApiEdgeMethod_1.ApiEdgeMethod("entryMethod", entryMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Entry),
        new ApiEdgeMethod_1.ApiEdgeMethod("collectionMethod", collectionMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Collection),
        new ApiEdgeMethod_1.ApiEdgeMethod("method", edgeMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Edge)
    ];
};
const edge2 = function () {
    this.name = "relatedEntry";
    this.pluralName = "relatedEntries";
    this.relations = [];
    this.methods = [
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedEntryMethod", relatedEntryMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Entry),
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedCollectionMethod", collectionMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Collection),
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedMethod", edgeMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Edge)
    ];
};
const edge3 = function () {
    this.name = "relatedCollectionEntry";
    this.pluralName = "relatedCollection";
    this.relations = [];
    this.methods = [
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedEntryMethod", entryMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Entry),
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedCollectionMethod", collectionMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Collection),
        new ApiEdgeMethod_1.ApiEdgeMethod("relatedMethod", edgeMethod, ApiEdgeMethod_1.ApiEdgeMethodScope.Edge)
    ];
};
const edge = new edge1;
const relatedEdge = new edge2;
const relatedCollectionEdge = new edge3;
const relation = new OneToOneRelation_1.OneToOneRelation(edge, relatedEdge);
const collectionRelation = new OneToManyRelation_1.OneToManyRelation(edge, relatedCollectionEdge);
const parser = new ApiRequestParser_1.ApiRequestPathParser(new Api_1.Api({ name: 'test-service', version: '1.0' })
    .edge(edge)
    .edge(relatedEdge)
    .edge(relatedCollectionEdge)
    .relation(relation)
    .relation(collectionRelation));
tap.test('path should be empty when the input array is empty', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse([]);
    t.equal(path.segments.length, 0);
    t.end();
}));
tap.test('parser should not allow missing edges', (t) => {
    t.throws(() => { parser.parse(['test']); }, 'Missing Edge: test', 'should not allow missing start edge');
    t.throws(() => { parser.parse(['entries', '42', 'test']); }, 'Missing Edge: test', 'should not allow missing related field/method 1');
    t.throws(() => { parser.parse(['entries', '42', 'relatedField', 'test']); }, 'Missing Edge: test', 'should not allow missing related field/method 2');
    t.throws(() => { parser.parse(['entries', '42', 'relatedField', 'relatedCollection']); }, 'Missing Relation: relatedEntry -> relatedCollection', 'should not allow missing relation');
    t.throws(() => { parser.parse(['entries', '42', 'relatedCollection', '11', 'test']); }, 'Missing Relation: relatedCollection -> test', 'should not allow missing related relation');
    t.end();
});
tap.test('parser should not allow invalid methods', (t) => {
    t.throws(() => { parser.parse(['entries', '42', 'collectionMethod']); }, 'Missing Relation/Method: entries -> collectionMethod', 'should not allow collection method on entry segment');
    t.throws(() => { parser.parse(['entries', '42', 'relatedField', 'relatedCollectionMethod']); }, 'Missing Relation/Method: entries -> relatedCollectionMethod', 'should not allow collection method on a related entry segment');
    t.end();
});
tap.test('parser should parse single edge segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries']);
    t.equal(path.segments.length, 1, 'should have one segment');
    t.ok(path.segments[0] instanceof request.EdgePathSegment, 'should have an edge path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.end();
}));
tap.test('parser should parse single entry segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', '42']);
    t.equal(path.segments.length, 1, 'should have one segment');
    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].id, '42', 'id should be the provided');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.end();
}));
tap.test('parser should parse single edge method segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', 'method']);
    t.equal(path.segments.length, 1, 'should have one segment');
    t.ok(path.segments[0] instanceof request.MethodPathSegment, 'should have a method path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].method.execute, edgeMethod, 'should be the registered method');
    t.end();
}));
tap.test('parser should parse single related entry segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', '42', 'relatedEntry']);
    t.equal(path.segments.length, 2, 'should have two segments');
    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].id, '42', 'id should be the provided');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.ok(path.segments[1] instanceof request.RelatedFieldPathSegment, 'should have a related field path segment');
    t.equal(path.segments[1].edge, edge, 'should be the registered edge');
    t.equal(path.segments[1].relation, relation, 'should be the registered relation');
    t.end();
}));
tap.test('parser should parse single entry method segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', '42', 'entryMethod']);
    t.equal(path.segments.length, 2, 'should have two segments');
    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].id, '42', 'id should be the provided');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.ok(path.segments[1] instanceof request.MethodPathSegment, 'should have a method path segment');
    t.equal(path.segments[1].edge, edge, 'should be the registered edge');
    t.equal(path.segments[1].method.execute, entryMethod, 'should be the registered method');
    t.end();
}));
tap.test('parser should parse single related entry method segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', '42', 'relatedEntry', 'relatedEntryMethod']);
    t.equal(path.segments.length, 3, 'should have two segments');
    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].id, '42', 'id should be the provided');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.ok(path.segments[1] instanceof request.RelatedFieldPathSegment, 'should have a related field path segment');
    t.equal(path.segments[1].edge, edge, 'should be the registered edge');
    t.equal(path.segments[1].relation, relation, 'should be the registered relation');
    t.ok(path.segments[2] instanceof request.MethodPathSegment, 'should have a method path segment');
    t.equal(path.segments[2].edge, relatedEdge, 'should be the registered edge');
    t.equal(path.segments[2].method.execute, relatedEntryMethod, 'should be the registered method');
    t.end();
}));
tap.test('parser should parse single related collection segment request', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const path = yield parser.parse(['entries', '42', 'relatedCollection']);
    t.equal(path.segments.length, 2, 'should have two segments');
    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');
    t.equal(path.segments[0].edge, edge, 'should be the registered edge');
    t.equal(path.segments[0].id, '42', 'id should be the provided');
    t.equal(path.segments[0].relation, null, 'should have no relation');
    t.ok(path.segments[1] instanceof request.EdgePathSegment, 'should have an edge path segment');
    t.equal(path.segments[1].edge, relatedCollectionEdge, 'should be the registered edge');
    t.equal(path.segments[1].relation, collectionRelation, 'should be the registered relation');
    t.end();
}));
tap.test('unsupported relation should cause error', (t) => {
    const unsupportedRelation = function () {
        this.name = "unsupported";
        this.from = edge;
        this.to = relatedEdge;
    };
    const badParser = new ApiRequestParser_1.ApiRequestPathParser(new Api_1.Api({ name: 'test-service', version: '1.0' })
        .edge(edge)
        .edge(relatedEdge)
        .relation(new unsupportedRelation));
    t.throws(() => { badParser.parse(['entries', '42', 'unsupported']); }, 'Unsupported Relation');
    t.end();
});
tap.test('request parser should work too', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const requestParser = new ApiRequestParser_1.ApiRequestParser(new Api_1.Api({ name: 'test-service', version: '1.0' }));
    const request = yield requestParser.parse([]);
    t.equal(request.path.segments.length, 0);
    t.end();
}));
//# sourceMappingURL=request-parser.js.map