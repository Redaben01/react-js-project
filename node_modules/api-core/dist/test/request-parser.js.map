{"version":3,"file":"request-parser.js","sourceRoot":"","sources":["../../test/request-parser.ts"],"names":[],"mappings":"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","sourcesContent":["const tap = require('tap');\n\nimport * as request from \"../src/request/ApiRequest\";\n\nimport {ApiEdgeQueryResponse} from \"../src/edge/ApiEdgeQueryResponse\";\nimport {ApiEdgeMethod, ApiEdgeMethodScope} from \"../src/edge/ApiEdgeMethod\";\nimport {ApiRequestPathParser, ApiRequestParser} from \"../src/request/ApiRequestParser\";\nimport {OneToManyRelation} from \"../src/relations/OneToManyRelation\";\nimport {OneToOneRelation} from \"../src/relations/OneToOneRelation\";\nimport {Api} from \"../src/Api\";\n\nconst entryMethod = (): Promise<ApiEdgeQueryResponse> => { return new Promise((resolve, reject) => reject(\"entry\")) };\nconst relatedEntryMethod = (): Promise<ApiEdgeQueryResponse> => { return new Promise((resolve, reject) => reject(\"entry\")) };\nconst collectionMethod = (): Promise<ApiEdgeQueryResponse> => { return new Promise((resolve, reject) => reject(\"collection\")) };\nconst edgeMethod = (): Promise<ApiEdgeQueryResponse> => { return new Promise((resolve, reject) => reject(\"edge\")) };\n\nconst edge1: any = function() {\n    this.name = \"entry\";\n    this.pluralName = \"entries\";\n    this.relations = [];\n    this.methods = [\n        new ApiEdgeMethod(\"entryMethod\", entryMethod, ApiEdgeMethodScope.Entry),\n        new ApiEdgeMethod(\"collectionMethod\", collectionMethod, ApiEdgeMethodScope.Collection),\n        new ApiEdgeMethod(\"method\", edgeMethod, ApiEdgeMethodScope.Edge)\n    ]\n};\n\nconst edge2: any = function() {\n    this.name = \"relatedEntry\";\n    this.pluralName = \"relatedEntries\";\n    this.relations = [];\n    this.methods = [\n        new ApiEdgeMethod(\"relatedEntryMethod\", relatedEntryMethod, ApiEdgeMethodScope.Entry),\n        new ApiEdgeMethod(\"relatedCollectionMethod\", collectionMethod, ApiEdgeMethodScope.Collection),\n        new ApiEdgeMethod(\"relatedMethod\", edgeMethod, ApiEdgeMethodScope.Edge)\n    ]\n};\n\nconst edge3: any = function() {\n    this.name = \"relatedCollectionEntry\";\n    this.pluralName = \"relatedCollection\";\n    this.relations = [];\n    this.methods = [\n        new ApiEdgeMethod(\"relatedEntryMethod\", entryMethod, ApiEdgeMethodScope.Entry),\n        new ApiEdgeMethod(\"relatedCollectionMethod\", collectionMethod, ApiEdgeMethodScope.Collection),\n        new ApiEdgeMethod(\"relatedMethod\", edgeMethod, ApiEdgeMethodScope.Edge)\n    ]\n};\n\nconst edge: any = new edge1;\nconst relatedEdge: any = new edge2;\nconst relatedCollectionEdge: any = new edge3;\nconst relation: any = new OneToOneRelation(edge, relatedEdge);\nconst collectionRelation: any = new OneToManyRelation(edge, relatedCollectionEdge);\n\nconst parser = new ApiRequestPathParser(\n    new Api({name: 'test-service', version: '1.0'})\n        .edge(edge)\n        .edge(relatedEdge)\n        .edge(relatedCollectionEdge)\n        .relation(relation)\n        .relation(collectionRelation)\n);\n\ntap.test('path should be empty when the input array is empty', async (t: any) => {\n    const path = await parser.parse([]);\n    t.equal(path.segments.length, 0);\n    t.end()\n});\n\ntap.test('parser should not allow missing edges', (t: any) => {\n    t.throws(() => { parser.parse([ 'test' ]) }, 'Missing Edge: test', 'should not allow missing start edge');\n    t.throws(() => { parser.parse([ 'entries', '42', 'test' ]) }, 'Missing Edge: test', 'should not allow missing related field/method 1');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedField', 'test' ]) }, 'Missing Edge: test', 'should not allow missing related field/method 2');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedField', 'relatedCollection' ]) }, 'Missing Relation: relatedEntry -> relatedCollection', 'should not allow missing relation');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedCollection', '11', 'test' ]) }, 'Missing Relation: relatedCollection -> test', 'should not allow missing related relation');\n\n    t.end()\n});\n\ntap.test('parser should not allow invalid methods', (t: any) => {\n    t.throws(() => { parser.parse([ 'entries', '42', 'collectionMethod' ]) }, 'Missing Relation/Method: entries -> collectionMethod', 'should not allow collection method on entry segment');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedField', 'relatedCollectionMethod' ]) }, 'Missing Relation/Method: entries -> relatedCollectionMethod', 'should not allow collection method on a related entry segment');\n\n    //TODO: These should produce entry requests.\n    //t.throws(() => { parser.parse([ 'entries', '42', 'relatedCollection', 'relatedEntryMethod' ]) }, 'Missing Relation/Method: entries -> relatedEntryMethod', 'should not allow entry method on a related collection segment');\n    //t.throws(() => { parser.parse([ 'entries', 'entryMethod' ]) }, 'Missing Relation/Method: entries -> entryMethod', 'should not allow entry method on collection segment');\n\n    t.end()\n});\n\ntap.test('parser should parse single edge segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries' ]);\n    t.equal(path.segments.length, 1, 'should have one segment');\n    t.ok(path.segments[0] instanceof request.EdgePathSegment, 'should have an edge path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n    t.end()\n});\n\ntap.test('parser should parse single entry segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', '42' ]);\n    t.equal(path.segments.length, 1, 'should have one segment');\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n    t.end()\n});\n\ntap.test('parser should parse single edge method segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', 'method' ]);\n    t.equal(path.segments.length, 1, 'should have one segment');\n    t.ok(path.segments[0] instanceof request.MethodPathSegment, 'should have a method path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.MethodPathSegment).method.execute, edgeMethod, 'should be the registered method');\n    t.end()\n});\n\ntap.test('parser should parse single related entry segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', '42', 'relatedEntry' ]);\n    t.equal(path.segments.length, 2, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.RelatedFieldPathSegment, 'should have a related field path segment');\n    t.equal(path.segments[1].edge, edge, 'should be the registered edge');\n    t.equal(path.segments[1].relation, relation, 'should be the registered relation');\n\n    t.end()\n});\n\ntap.test('parser should parse single entry method segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', '42', 'entryMethod' ]);\n    t.equal(path.segments.length, 2, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.MethodPathSegment, 'should have a method path segment');\n    t.equal(path.segments[1].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[1] as request.MethodPathSegment).method.execute, entryMethod, 'should be the registered method');\n\n    t.end()\n});\n\ntap.test('parser should parse single related entry method segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', '42', 'relatedEntry', 'relatedEntryMethod' ]);\n    t.equal(path.segments.length, 3, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.RelatedFieldPathSegment, 'should have a related field path segment');\n    t.equal(path.segments[1].edge, edge, 'should be the registered edge');\n    t.equal(path.segments[1].relation, relation, 'should be the registered relation');\n\n    t.ok(path.segments[2] instanceof request.MethodPathSegment, 'should have a method path segment');\n    t.equal(path.segments[2].edge, relatedEdge, 'should be the registered edge');\n    t.equal((path.segments[2] as request.MethodPathSegment).method.execute, relatedEntryMethod, 'should be the registered method');\n\n    t.end()\n});\n\ntap.test('parser should parse single related collection segment request', async (t: any) => {\n    const path = await parser.parse([ 'entries', '42', 'relatedCollection' ]);\n    t.equal(path.segments.length, 2, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.EdgePathSegment, 'should have an edge path segment');\n    t.equal(path.segments[1].edge, relatedCollectionEdge, 'should be the registered edge');\n    t.equal(path.segments[1].relation, collectionRelation, 'should be the registered relation');\n\n    t.end()\n});\n\ntap.test('unsupported relation should cause error', (t: any) => {\n    const unsupportedRelation: any = function() {\n        this.name = \"unsupported\";\n        this.from = edge;\n        this.to = relatedEdge;\n    };\n\n    const badParser = new ApiRequestPathParser(\n        new Api({name: 'test-service', version: '1.0'})\n        .edge(edge)\n            .edge(relatedEdge)\n            .relation(new unsupportedRelation)\n    );\n\n    t.throws(() => { badParser.parse([ 'entries', '42', 'unsupported' ]) }, 'Unsupported Relation');\n    t.end()\n});\n\ntap.test('request parser should work too', async (t: any) => {\n    const requestParser = new ApiRequestParser(new Api({name: 'test-service', version: '1.0'}));\n    const request = await requestParser.parse([]);\n    t.equal(request.path.segments.length, 0);\n    t.end()\n});\n"]}