"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelEdge = exports.Model = void 0;
const ApiEdgeDefinition_1 = require("../../../src/edge/ApiEdgeDefinition");
const ApiEdgeQueryFilter_1 = require("../../../src/edge/ApiEdgeQueryFilter");
const ApiEdgeQueryResponse_1 = require("../../../src/edge/ApiEdgeQueryResponse");
const ApiEdgeError_1 = require("../../../src/query/ApiEdgeError");
class Model {
    constructor(obj) {
        this.id = obj.id;
    }
}
exports.Model = Model;
class ModelEdge extends ApiEdgeDefinition_1.ApiEdge {
    constructor() {
        super(...arguments);
        this.name = "entry";
        this.pluralName = "entries";
        this.idField = "id";
        this.fields = [];
        this.provider = [];
        this.methods = [];
        this.relations = [];
        this.inspect = () => `/${this.pluralName}`;
        this.getEntry = (context) => {
            return new Promise((resolve, reject) => {
                let entry = this.provider.find((s) => s.id === context.id && this.applyFilters(s, context.filters));
                if (entry)
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(this.applyMapping(entry, context.fields)));
                else
                    reject(new ApiEdgeError_1.ApiEdgeError(404, "Not Found"));
            });
        };
        this.listEntries = (context) => {
            return new Promise((resolve) => {
                resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(this.provider
                    .filter(item => this.applyFilters(item, context.filters))
                    .map(entry => this.applyMapping(entry, context.fields))));
            });
        };
        this.createEntry = (context, body) => {
            return new Promise((resolve) => {
                let entry = this.createModel(body);
                this.provider.push(entry);
                resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(this.applyMapping(entry, context.fields)));
            });
        };
        this.updateEntry = (context, body) => {
            return new Promise((resolve, reject) => {
                this.getEntry(context).then(() => {
                    body.id = context.id;
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(this.applyMapping(body, context.fields)));
                }).catch(reject);
            });
        };
        this.patchEntry = (context, body) => {
            return new Promise((resolve, reject) => {
                this.getEntry(context).then((resp) => {
                    let entry = resp.data;
                    Object.keys(body).forEach((key) => entry[key] = body[key]);
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(this.applyMapping(entry, context.fields)));
                }).catch(reject);
            });
        };
        this.removeEntry = (context) => {
            return new Promise((resolve, reject) => {
                this.getEntry(context).then((entry) => {
                    this.provider.splice(this.provider.indexOf(entry), 1);
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(entry));
                }).catch(reject);
            });
        };
        this.exists = (context) => {
            return new Promise((resolve) => {
                let entry = this.provider.find((s) => s.id === context.id);
                if (entry)
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(true));
                else
                    resolve(new ApiEdgeQueryResponse_1.ApiEdgeQueryResponse(false));
            });
        };
    }
    applyMapping(item, fields) {
        if (!fields.length)
            return item;
        let output = {};
        Object.keys(item).filter(key => fields.indexOf(key) != -1).forEach(key => output[key] = item[key]);
        return output;
    }
    static applyFilter(item, filter) {
        switch (filter.type) {
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.Equals:
                return item[filter.field] === filter.value;
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.NotEquals:
                return item[filter.field] !== filter.value;
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.GreaterThan:
                return item[filter.field] > filter.value;
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.GreaterThanOrEquals:
                return item[filter.field] >= filter.value;
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.LowerThan:
                return item[filter.field] < filter.value;
            case ApiEdgeQueryFilter_1.ApiEdgeQueryFilterType.LowerThanOrEquals:
                return item[filter.field] <= filter.value;
            default:
                return false;
        }
    }
    applyFilters(item, filters) {
        if (!filters.length)
            return true;
        return filters.every(filter => ModelEdge.applyFilter(item, filter));
    }
}
exports.ModelEdge = ModelEdge;
//# sourceMappingURL=ModelEdge.js.map